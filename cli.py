# from junipernetops.juniper import Juniper
from netopsauto.juniper import Juniper
from datetime import datetime
import secrets
import json
import argparse
import sys

def audit_interfaces(switch, enabled_interfaces, interface_to_status):
    # returns a list of ports which need to be activated for the given switchs

    # For each enabled interface, if the port exists in the interface status dictionary and is inactive, increment the counter
    count = sum(1 for i in enabled_interfaces if i in interface_to_status and interface_to_status[i] == 'inactive')
    print("Number of enabled interfaces with port security for {} : {}\n".format(switch.host_name, count))

    interfaces = []

    # If there is more than one port that needs to be enabled
    if count > 0 :
        for i in enabled_interfaces:
            # For each enabled interface, if the port exists in the interface status dictionary 
            # and is inactive, store the portin the interfaces list
            if i in interface_to_status and interface_to_status[i] == 'inactive':
                interfaces.append(i)
    
    return interfaces


def switches_to_list():

    # Input the buildings you would like ommitted ex: ['Townhomes', 'Horner Ballpark']
    SKIPPED_BUILDINGS = []

    switches = []
    with open('./data/input/switches.json', 'r') as f:
        data = json.loads(f.read())
        for building in data:
            for value in data[building]:
                # Skip the buildings listed in SKIPPED buildings and add the switches whose switch type is accesss
                if building not in SKIPPED_BUILDINGS and value['switch_type'] == "access":
                    switch = Juniper(value['host_name'], value['host_address'], secrets.username, secrets.password)
                    switches.append(switch)

    return switches

def output_audit():
    # Compare the output of the enabled interfaces with the secure-access-port status 
    # to generate an audit of ports that should have their security enabled
    swlist = switches_to_list()

    # Create a dictionary to contain the output of the audit
    output_json = {}

    for sw in swlist:
        try:
            # store the list of enabled interfaces
            enabled_interfaces = sw.get_enabled_interfaces()
            # store the dictionary of ports and their security status
            interface_to_status = sw.get_secure_access_port_status()
            print("Scanning {} for port security".format(sw.host_name))
            output_json[sw.host_name] = {}
            output_json[sw.host_name]['ipaddress'] = sw.host_address
            # set the list of ports to the output generated by audit_interfaces()
            output_json[sw.host_name]['ports'] = audit_interfaces(sw, enabled_interfaces, interface_to_status)  
        except Exception as e:
            print("Could Not Connect To Device: {}".format(e))
            pass

    filename = "./data/output/port-security-audit-{}.json".format(datetime.now().strftime("%m-%d-%Y"))
    # filename = "./data/output/port-security-audit.json"
    with open(filename, 'w') as f:
        json.dump(output_json, f, indent=4)


def activate_security():
    # run this function after output_audit()
    # replace filename with the date of the most recent port-sexurity-audit result
    with open('./data/output/port-security-audit.json', 'r') as f:
        data = json.loads(f.read())
        for building in data:
            address = data['building']['ipaddress']
            ports = data[building]['ports']
            if(len(ports) > 0):
                sw = Juniper(building, address, secrets.username, secrets.password)
                sw.activate_port_security(ports)

def set_recue():
    # will set the rescue config for all of the switches specified in switches_to_list()
    swlist = switches_to_list()

    for sw in swlist:
        sw.set_rescue_config()

def set_snmp():
    # will set the snmp for all of the switches specified in switches_to_list()
    swlist = switches_to_list()

    for sw in swlist:
        # set the community, trap, and ip address for the current switch
        sw.set_snmp('community', 'trap', '1.1.1.1')

if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    # command line arguments that can be passed in to the cli
    FUNCTIONMAP = {'outputaudit' : output_audit, 'activatesecurity' : activate_security, 'listswitches' : switches_to_list, 'setrescue' : set_recue, 'setsnmp' : set_snmp}
    
    parser.add_argument('command', choices=FUNCTIONMAP.keys())

    args = parser.parse_args()

    func = FUNCTIONMAP[args.command]

    func()
